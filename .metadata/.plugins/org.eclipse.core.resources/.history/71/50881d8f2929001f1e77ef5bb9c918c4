package com.kh.spring.string.controller;

public class StringController {
	
	// String 클래스 => 특징? 불변(변하지 않음을 의미).
	
	int num = 1; //(단순한 정수)
	boolean flag = true; //(논리)
	
	/*
	 * 논리 : 실체가 없는 것
	 * 물리 : 실체가 있는 것
	 * 
	 * 배열 : 논리적인 구조와 물리적인 구조가 동일함!
	 */
	
	int[] numArr = {1,2,3,4,5};
	int num1 = numArr[0]; // 인덱스 : 실체가 없으므로 논리적인 구조 
	int num2 = numArr[1];
	int num3 = numArr[2];
	
	// charArray
	//String str;

	
	/*
	 * String 클래스의 객체 생성 방법
	 * 
	 * 1. 대입연산자를 통해서 String리터럴을 대입하는 방법 ★
	 * 2. 생성자를 호출해서 String객체로 만들어주는 방법 X
	 * 
	 * Why? => 
	 * 
	 */
	
	//생성자를 호출해서 String 객체를 생성
	public void constructorString() {
	
		String str1 = new String("Hello");
		String str2 = new String("Hello");
		
		String[] strArr = {};
		
		
		
		//toString()
		System.out.println(str1.toString());
		System.out.println(str2);
		
		// System.out.println(strArr);
		
		// 1. String클래스의 toString의 경우
		// 실제 담겨있는 문자열 리터럴을 반환하게끔 오버라이딩
		
		//equals() => 주소값을 비교하는 것이 아닌 실제 문자열 리터럴값을 비교하도록 오버라이딩.
		System.out.println(str1.equals(str2));
		
		// hashCode() 
		// 16진수는 알아보기 힘드니까 => int형 10진수
		System.out.println(str1.hashCode());
		System.out.println(str2.hashCode());
		System.out.println("Hello".hashCode());
		//주소값을 해싱하는 것이 아니라 실제 담긴 문자열을 기반으로 해시코드값을 만들어서 반환.
		
		// 해시코드에 오버라이딩되어있는 값 비교가 불가능하다. 
		// => 식별 할 수 있는 값? System.indentityHashCode(참조형변수);
		System.out.println(System.identityHashCode(str1));
		System.out.println(System.identityHashCode(str2));
		// => 실제 str1과 str2는 주소값이 다르다.
		System.out.println(str1 == str2);
	}
	
	// 리터럴 대입방식
	public void stringAssign() {
		String str1 = "Hello";
		String str2 = "Hello";
	}
}
